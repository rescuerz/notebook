# åä¸‰. Randomized Algorithms

efficient randomized algorithms that only need to yield the correct answer with high probability

randomized algorithms that are always correct, and run efficiently in expectation

![image-20240513114316001](https://zn-typora-image.oss-cn-hangzhou.aliyuncs.com/typora_image/202405131143039.png)



## 13.1 The Hiring Problem

- Hire an office assistant from headhunter 

- Interview a different applicant per day for N days

- Interviewing $Cost = C_i  <<  Hiring Cost = C_h$

  $é¢è¯•æˆæœ¬ = C_i << æ‹›è˜æˆæœ¬ = C_h$

- Analyze interview & hiring cost instead of running time

  åˆ†æé¢è¯•å’Œæ‹›è˜æˆæœ¬è€Œä¸æ˜¯è¿è¡Œæ—¶é—´

**Assume** **M** **people are hired.** **Total Cost: $O(NC_i + MC_h)$**

```
int Hiring ( EventType C[ ], int N )
{   /* candidate 0 is a least-qualified dummy candidate */
    int Best = 0;
    int BestQ = the quality of candidate 0;
    for ( i=1; i<=N; i++ ) {
        Qi = interview( i ); /* Ci */
        if ( Qi > BestQ ) {
            BestQ = Qi;
            Best = i;
            hire( i );  /* Ch */
        }
    }
    return Best;
}
```

**worse case: The candidates come in increasing quality order**.

**`æœ€åçš„æƒ…å†µæ˜¯ï¼šé¢è¯•è€…çš„ç´ è´¨ä¸€æ¬¡é€’å¢ï¼Œç›¸å½“äºæ¯é¢è¯•ä¸€ä¸ªäººï¼Œå°±ä¼šæ‹›å‹Ÿä¸€ä¸ªäºº`**

æ—¶é—´å¤æ‚åº¦ä¸ºï¼š$O(NC_h)$

> **Assume candidates arrive in random order**
>
> **Randomness assumption: any of first i candidates is equally likely to be best-qualified so far.**
>
> **éšæœºæ€§å‡è®¾ï¼šåˆ°ç›®å‰ä¸ºæ­¢ï¼Œå‰ i åå€™é€‰äººä¸­çš„ä»»ä½•ä¸€ä¸ªéƒ½åŒæ ·å¯èƒ½æœ€æœ‰èµ„æ ¼**

![image-20240513115229090](https://zn-typora-image.oss-cn-hangzhou.aliyuncs.com/typora_image/202405131152204.png)

**`å‰iä¸ªå€™é€‰äººï¼Œä»»ä½•ä¸€ä¸ªéƒ½å¯èƒ½è¢«å½•å–ã€‚ä»¥ç¬¬iä¸ªäººä¸ºä¾‹ï¼Œç¬¬iä¸ªäººè¢«å½•å–ï¼Œæ„å‘³ç€å®ƒçš„èƒ½åŠ›æ¯”å‰é¢æ‰€æœ‰äººçš„èƒ½åŠ›éƒ½å¼ºï¼Œæ­¤æ—¶çš„æ¦‚ç‡æ˜¯1/iï¼Œå¯¹åº”çš„æœŸæœ›å°±æ˜¯1*1/i + 0*(i-1)/i = 1/i`**

æ‰€ä»¥æœ€ç»ˆçš„æœŸæœ›ä¸º$E[X] = E[\sum_{i=1}^NX_i] = \sum_{i=1}^NE[X_i] = \sum_{i=1}^N \dfrac{1}{i} = lnN$ã€‚ä»˜å‡ºçš„æ€»ä»£ä»·ä¸º$O(C_hlnN+NC_i)$

```
int RandomizedHiring ( EventType C[ ], int N )
{   /* candidate 0 is a least-qualified dummy candidate */
    int Best = 0;
    int BestQ = the quality of candidate 0;

    randomly permute the list of candidates;

    for ( i=1; i<=N; i++ ) {
        Qi = interview( i ); /* Ci */
        if ( Qi > BestQ ) {
            BestQ = Qi;
            Best = i;
            hire( i );  /* Ch */
        }
    }
}
```

### 13.1.1 Randomized Permutation Algorithm

![image-20240513120022015](https://zn-typora-image.oss-cn-hangzhou.aliyuncs.com/typora_image/202405131200094.png)

### 13.1.2 Online Hiring Algorithm

> **hire only once**

```
int OnlineHiring ( EventType C[ ], int N, int k)
{
    int Best = N;
    int BestQ = - ï‚¥ ;
    for ( i=1; i<=k; i++ ) {
        Qi = interview( i );
        if ( Qi > BestQ )   BestQ = Qi;
    }
    for ( i=k+1; i<=N; i++ ) {
        Qi = interview( i );
        if ( Qi > BestQ ) {
            Best = i;
            break;
        }
    }
    return Best;
}
```

**`å‰é¢kä¸ªäººä»…ç”¨äºæµ‹è¯•è¯„ä¼°é¢è¯•è€…çš„æ°´å¹³(æŒ‘é€‰å‡ºæœ€é«˜çš„ç´ è´¨)ï¼Œé›‡ä½£äººä»k+1ä¸ªäººå¼€å§‹ï¼Œæ¯ä¸ªäººçš„qualityéƒ½ä¸æœ€é«˜çš„çš„qualityè¿›è¡Œæ¯”è¾ƒï¼Œé€‰æ‹©å‡ºæœ€å¥½çš„`**

> **What is the probability we hire the best qualified candidate for a given k?**

![image-20240513120814777](https://zn-typora-image.oss-cn-hangzhou.aliyuncs.com/typora_image/202405131208856.png)

**`æœ€å¥½çš„é¢è¯•è€…åœ¨ç¬¬iä¸ªä½ç½®ï¼Œè¦æ±‚i>k,å¹¶ä¸”ä»k+1åˆ°i-1çš„é¢è¯•è€…éƒ½æ²¡æœ‰è¢«é›‡ä½£`**

> **What is the best value of k to maximize above probability?**

- ç”¨$S_i$è¡¨ç¤ºç¬¬$i$ä¸ªå€™é€‰è€…æ˜¯æœ€å¥½çš„

- è¦ä½¿ç¬¬$i$ä¸ªäººæ˜¯æœ€å¥½çš„ï¼Œéœ€è¦æ»¡è¶³ç¬¬$i$ä¸ªäººé¦–å…ˆqualityéœ€è¦å¤§äºbestQï¼Œç„¶åä»$k+1$åˆ°$i-1$ä¸ªäººæ²¡æœ‰äººçš„qualityå¤§äºbestQï¼Œä¹Ÿå°±æ˜¯è¯´æ²¡æœ‰äººè¢«hireï¼ˆ**`å› ä¸ºä»ä¸Šæ–¹ä»£ç å¯ä»¥çœ‹å‡ºä¸€æ—¦æŸä¸ªäººçš„qualityå¤§äºbestQï¼Œå°±ä¼šbreak`**ï¼‰

  **ä»ç¬¬$k+1$åˆ°ç¬¬$i-1$æ²¡æœ‰å½•äºä»»ä½•äººã€‚è¿™æ„å‘³ç€å‰$i-1$ä¸ªäººé‡Œé¢ï¼Œæœ€å¥½çš„è½åœ¨äº†å‰$k$ä¸ªäººä¹‹ä¸­ï¼Œæ¦‚ç‡å°±æ˜¯$\dfrac{k}{i-1}$**

- æ­¤æ—¶æ¦‚ç‡ä¸º$P[S_i] = P[A\cap B] = P[A]\times P[B] = \dfrac{1}{N} \times \dfrac{k}{i-1} = \dfrac{k}{N(i-1)}$

- é‚£ä¹ˆæœ€å¥½çš„é¢è¯•è€…å‡ºç°åœ¨ç¬¬$k$ä¸ªäººä¹‹åçš„æ¦‚ç‡ä¸ºï¼š
  $$
  P[S] = \sum_{i=k+1}^N P[S_i] = \sum_{i=k+1}^N \dfrac{k}{N(i-1)} = \dfrac{k}{N}\sum_{i=k}^{N-1} \dfrac{1}{i}
  $$
  

![image-20240520112401117](https://zn-typora-image.oss-cn-hangzhou.aliyuncs.com/typora_image/202405201124348.png)

<img src="https://zn-typora-image.oss-cn-hangzhou.aliyuncs.com/typora_image/202405201124962.png" alt="image-20240520112407882" style="zoom:50%;" />

## 13.2 Quicksort

- Deterministic Quicksort
  - $\Theta(N^2)$ **`worst-case running time`**
  - $\Theta(N logN)$**`average case running time`**

> **è¦æƒ³åŠ é€Ÿquicksortï¼Œæ¯ä¸€æ¬¡å°†æ•°æ®ä¸€åˆ†ä¸ºäºŒæ—¶ï¼Œå¸Œæœ›ä¸¤è¾¹çš„æ•°æ®å¤§è‡´ç›¸ç­‰**

**Central splitter := the pivot that divides the set so that each side contains at least n/4**

**`Central splitter := åˆ’åˆ†é›†åˆçš„ä¸»å…ƒï¼Œä½¿å¾—æ¯è¾¹è‡³å°‘åŒ…å« n/4`**

**Modified Quicksort := always select a central splitter before recursions**

**`ç›¸å½“äºé€‰æ‹©pivotçš„èŒƒå›´åœ¨[n/4,3n/4].é€‰æ‹©åˆ°central splitterçš„æ¦‚ç‡æ˜¯1/2`**

å¦‚æœç¬¬ä¸€æ¬¡æ²¡æœ‰é€‰æ‹©åˆ°ï¼Œå°±å†æ¬¡é€‰æ‹©ã€‚æœŸæœ›æ¬¡æ•°ä¸ºï¼š
$$
\begin{aligned}
&1 \times 1/2 + 2 \times 1/4 + 3\times 1/8 + ...\\
= &\sum_{i=1}^\infin i \times \dfrac{1}{2^i}\\
= & (1/2+1/4+...) + (1/4+1/8+...)+(1/8+1/16+..)+..\\
= & 1 + 1/2 + 1/4 + ..\\
= &2
\end{aligned}
$$

****

![image-20240520114932791](https://zn-typora-image.oss-cn-hangzhou.aliyuncs.com/typora_image/202405201149863.png)

åˆ’åˆ†jæ¬¡ä¹‹åï¼Œå­é—®é¢˜çš„æœ€å¤§å°ºå¯¸æ˜¯$N (\dfrac{3}{4})^{j+1} \leq |S| \leq N (\dfrac{3}{4})^{j}$

**`æŒ‰ç…§å­é—®é¢˜çš„æœ€å¤§å°ºå¯¸æ¥ï¼Œç›¸åº”çš„å­é—®é¢˜çš„æœ€å¤§æ•°é‡ä¸º`$(\dfrac{4}{3})^{j+1}$,æ­¤æ—¶æ°å¥½ï¼Œå­é—®é¢˜çš„æ•°é‡ä¹˜ä»¥å­é—®é¢˜çš„è§„æ¨¡å¾—åˆ°N**

**è§£å†³ç±»å‹jæ‰€éœ€çš„æ—¶é—´å¤æ‚åº¦ä¸º**ï¼š$E[T_{type \ j}] = O(N(\dfrac{3}{4})^j)\times (\dfrac{4}{3})^{j+1} = O(N)$

**å…¶ä¸­é—®é¢˜çš„ç±»å‹æ˜¯$log_{\frac{4}{3} }N$**,**`å› ä¸ºé—®é¢˜çš„æœ€å°è§„æ¨¡éœ€è¦ä¸º1`**

**æ‰€ä»¥æ€»çš„æœŸæœ›æ—¶é—´å¤æ‚åº¦ä¸º**$O(N) \times O(logN) = O(NlogN)$

## 13.3 ä¹ é¢˜é›†

1. Let $a=\left(a_{1}, a_{2}, \ldots, a_{i}, \ldots, a_{j}, \ldots, a_{n}\right)$ denote the list of elements we want to sort. In the quicksort algorithm, if the pivot is selected uniformly at random. Then any two elements get compared at most once and the probability of $a_{i}$ and $a_{j}$ being compared is $2 /(j-i+1)$ for $j>i$, given that $a_{i}$ or $a_{j}$ is selected as the pivot. (T/F)

   **`F`**

   > **ä¸¾åä¾‹å¦‚ä¸‹ï¼š\{3, 4, 1, 2, \}ã€‚å¦‚æœç¬¬ä¸€æ¬¡é€‰pivoté€‰ä¸­3æˆ–è€…2ï¼Œé‚£ä¹ˆ1å’Œ4ä¼šè¢«åˆ†å¼€ï¼Œä¸ä¼šè¢«æ¯”è¾ƒã€‚**
   >
   > **å¦‚æœç¬¬ä¸€æ¬¡å°±é€‰ä¸­1æˆ–4ï¼Œå®ƒä»¬æ‰ä¼šè¢«æ¯”è¾ƒã€‚å› æ­¤å®ƒä»¬è¢«æ¯”è¾ƒçš„æ¦‚ç‡æ˜¯1/2ã€‚æŒ‰ç…§ $\dfrac{2}{j-i+1}$ è®¡ç®—ï¼Œåº”è¯¥æ˜¯1ã€‚**
   >
   > **äº‹å®ä¸Šï¼Œå¦‚æœæ˜¯å·²ç»è¢«æ’åºå¥½çš„ï¼Œè¿™å°±æ˜¯å¯¹çš„ã€‚**

2. Given a linked list containing $N$ nodes. Our task is to remove all the nodes. At each step, we randomly choose one node in the current list, then delete the selected node together with all the nodes after it. Here we assume that each time we choose one node uniformly among all the remaining nodes. What is the expected number of steps to remove all the nodes?

   A.$\Theta (\log N)$

   B.$N/e$

   C.$N/2$

   D.$\sqrt{N}$

   **`A`**

   > 1. åˆå§‹æ—¶ï¼Œé“¾è¡¨æœ‰ ğ‘*N* ä¸ªèŠ‚ç‚¹ã€‚
   > 2. åœ¨æ¯ä¸€æ­¥ä¸­ï¼Œæˆ‘ä»¬éšæœºé€‰æ‹©å½“å‰é“¾è¡¨ä¸­çš„ä¸€ä¸ªèŠ‚ç‚¹ï¼Œåˆ é™¤è¯¥èŠ‚ç‚¹åŠå…¶ä¹‹åçš„æ‰€æœ‰èŠ‚ç‚¹ã€‚
   > 3. ç›®æ ‡æ˜¯è®¡ç®—å®Œå…¨åˆ é™¤é“¾è¡¨ä¸­æ‰€æœ‰èŠ‚ç‚¹æ‰€éœ€çš„é¢„æœŸæ­¥éª¤æ•°ã€‚

   **å‡è®¾ ğ¸(ğ‘)è¡¨ç¤ºä»æœ‰ ğ‘ ä¸ªèŠ‚ç‚¹çš„é“¾è¡¨ä¸­åˆ é™¤æ‰€æœ‰èŠ‚ç‚¹æ‰€éœ€çš„é¢„æœŸæ­¥éª¤æ•°**

   å¦‚æœæˆ‘ä»¬é€‰æ‹©ç¬¬ ğ‘– ä¸ªèŠ‚ç‚¹ï¼ˆå…¶ä¸­ ğ‘– çš„èŒƒå›´æ˜¯ä» 1 åˆ° ğ‘ ï¼‰ï¼Œåˆ™è¯¥é€‰æ‹©ä¼šåˆ é™¤ä»ç¬¬ ğ‘– ä¸ªèŠ‚ç‚¹åˆ°æœ«å°¾çš„æ‰€æœ‰èŠ‚ç‚¹ã€‚å› æ­¤ï¼Œåœ¨è¿™ä¸€æ­¥ä¸­åˆ é™¤äº†$ ğ‘âˆ’ğ‘–+1$ä¸ªèŠ‚ç‚¹ã€‚

   **`é¦–å…ˆå…ˆåœ¨Nä¸ªç‚¹ä¸­ä»»é€‰ä¸€ä¸ªç‚¹ï¼Œæ‰§è¡Œä¸€æ­¥æ“ä½œï¼Œå‡è®¾é€‰å–ç¬¬iä¸ªç‚¹ï¼Œé‚£ä¹ˆå‰©ä½™çš„ç‚¹ä¸ºi-1ï¼Œåç»­åªéœ€è¦æ±‚E(i-1)`**

   é‚£ä¹ˆå¾—åˆ°é€’å½’å…³ç³»å¼ï¼š$E(N) = 1 + \dfrac{1}{N}\sum_{i=1}^NE(i-1) = 1 + \dfrac{1}{N}\sum_{i=0}^{N-1}E(i)$

   - ç›´æ¥ä»£å…¥ B,Cï¼Œæ˜¾ç„¶ä¸å¯¹ã€‚äº‹å®ä¸Šï¼Œå¯ä»¥çœ‹åˆ°è¿™ç§é€’æ¨å¼åªå¯èƒ½å‡ºæœ‰ç†æ•°ï¼ŒD å¾ˆå¯èƒ½å‡ºæ— ç†æ•°ï¼Œä¹Ÿä¸å¯¹ã€‚

   - ç„¶è€Œï¼Œå¾ˆè½»æ¾å°±å¯ä»¥é€šè¿‡å¼ºå½’çº³æ³•åˆ¤æ–­ $a_n=O(\log N)$ã€‚($\Omega$æ²¡æœ‰è¯•è¿‡ï¼Œåº”è¯¥ä¹Ÿå¯ä»¥ã€‚)
     $$
     a_n = \frac{1}{N}\sum_{i=1}^{N-1}a_i+1
     \leqslant \frac{C}{N}\log\left(2N\prod_{i=1}^{N-1}i\right)
     \leqslant C\log N
     $$
     è¿™é‡Œçš„ç¬¬äºŒä¸ªä¸ç­‰å·å¹¶ä¸é‚£ä¹ˆä¸¥æ ¼ï¼Œä¸è¿‡ $N$ è¶³å¤Ÿå¤§çš„æ—¶å€™ä¸€å®šæ˜¯ä¸¥æ ¼çš„ã€‚

3. Use The Online Hiring Algorithm ( hire only once ). Assume that the quality input $C[ ]$ is uniformly random.

   ```cpp
   int OnlineHiring ( EventType C[ ], int N, int k )
   {
       int Best = N;
       int BestQ = -INFINITY ;
       for ( i=1; i<=k; i++ ) {
           Qi = interview( i );
           if ( Qi > BestQ )   BestQ = Qi;
       }
       for ( i=k+1; i<=N; i++ ) {
           Qi = interview( i );
           if ( Qi > BestQ ) {
               Best = i;
               break;
           }
       }
       return Best;
   }
   ```

   

   When $N = 271$ and $k = 90$, the probability of hiring the Nth candidate is \_\_.

   **`1/3ã€‚è¦æ±‚å‰ 270 äººä¸­æœ€å¥½çš„è½åœ¨å‰ 90 äººä¸­ã€‚`**

   > ä¹Ÿå¯ä»¥åˆ†å‰ 271 äººä¸­æœ€å¥½çš„åœ¨å“ªé‡Œè¿›è¡Œè®¨è®ºï¼Œå³
   >
   > $$
   > \frac{1}{N}\cdot \frac{k}{N-1} + \frac{k}{N} = \frac{1}{3}
   > $$